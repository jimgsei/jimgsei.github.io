<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hundir la Flota ⚓</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0d1b2a;
            --primary-color: #1b263b;
            --secondary-color: #415a77;
            --accent-color: #e0e1dd;
            --highlight-color: #3a86ff;
            --hit-color: #ff4d6d;
            --sunk-color: #c9184a;
            --damaged-color: #ff9e00;
            --miss-color: #778da9;
            --font-family: 'Poppins', sans-serif;
            --grid-size: 10;
            --cell-size: min(8.5vw, 40px);
            --gap: 2px;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { overscroll-behavior: none; }
        body { font-family: var(--font-family); background-color: var(--bg-color); color: var(--accent-color); display: flex; justify-content: center; align-items: center; min-height: 100vh; padding: 1rem; }
        #app-container { width: 100%; max-width: 1200px; margin: auto; }
        .screen { display: none; flex-direction: column; align-items: center; justify-content: center; text-align: center; width: 100%; animation: fadeIn 0.5s ease-in-out; }
        .screen.active { display: flex; }
        .screen-content { background-color: var(--primary-color); padding: 1.5rem; border-radius: 15px; width: 100%; max-width: 500px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2); }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.98); } to { opacity: 1; transform: scale(1); } }
        .title { font-size: 2.5rem; color: var(--highlight-color); font-weight: 700; }
        h2 { font-size: 1.8rem; margin-bottom: 1rem; }
        h3 { font-size: 1.2rem; color: var(--highlight-color); margin-bottom: 0.5rem; }
        .btn { background: var(--secondary-color); color: var(--accent-color); border: none; padding: 0.7rem 1rem; font-size: 0.9rem; font-weight: 600; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; margin: 0.3rem; min-width: 110px; text-align: center; }
        .btn:hover { transform: translateY(-3px); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); }
        .btn.btn-danger { background-color: #a31a1a; color: white; }
        .btn.btn-primary { background-color: var(--highlight-color); color: white; }
        .grid-container {
    display: grid;
    grid-template-columns: repeat(var(--grid-size), var(--cell-size));
    grid-template-rows: repeat(var(--grid-size), var(--cell-size));
    gap: var(--gap);
    border: 2px solid var(--secondary-color);
    border-radius: 8px;
    background-color: var(--bg-color);
    width: fit-content; 
    margin: 0 auto;     
}
        .cell { width: var(--cell-size); height: var(--cell-size); background-color: var(--primary-color); border-radius: 2px; transition: background-color 0.2s ease; position: relative; }
        #placement-screen .screen-content, #game-screen .screen-content, #game-over-screen .screen-content { max-width: fit-content; }
        .placement-layout { display: flex; flex-direction: column; align-items: center; gap: 1.5rem; width: 100%; }
        #ship-selection-panel { background: var(--bg-color); padding: 1rem; border-radius: 8px; width: 100%; max-width: 300px; }
        #placement-controls { display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center; margin-top: 1rem; }
        #ship-list .ship-item { padding: 0.7rem; margin: 0.5rem 0; background-color: var(--secondary-color); border-radius: 5px; transition: all 0.3s ease; font-weight: 600; cursor: pointer; }
        #ship-list .ship-item.placing { background-color: var(--highlight-color); color: white; transform: scale(1.05); box-shadow: 0 0 15px var(--highlight-color); }
        #ship-list .ship-item.placed { opacity: 0.5; background-color: var(--bg-color); cursor: default; }
        .cell.preview { background-color: rgba(58, 134, 255, 0.5); }
        .cell.invalid { background-color: rgba(255, 77, 109, 0.5); }
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(13, 27, 42, 0.95); z-index: 100; }
        .modal .screen-content { box-shadow: none; background: transparent; }
        #game-header { width: 100%; margin-bottom: 1rem; }
        #ships-status-panel { display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center; background-color: var(--bg-color); padding: 0.5rem; border-radius: 8px; }
        .ship-status { padding: 0.3rem 0.6rem; font-size: 0.8rem; background-color: var(--secondary-color); border-radius: 5px; opacity: 0.7; }
        .ship-status.damaged { background-color: var(--damaged-color); color: #000; opacity: 1; }
        .ship-status.sunk { background-color: var(--sunk-color); text-decoration: line-through; opacity: 1; }
        #attack-grid.grid-container .cell { cursor: crosshair; }
        #attack-grid.grid-container .cell:not(.hit):not(.miss):hover { background-color: var(--secondary-color); }
        .cell.hit { background-color: var(--hit-color); animation: hit-animation 0.3s ease-out; }
        .cell.miss { background: repeating-linear-gradient(45deg, var(--primary-color), var(--primary-color) 2px, var(--miss-color) 2px, var(--miss-color) 4px); }
        .cell.sunk { background-color: var(--sunk-color); }
        @keyframes hit-animation { 0% { transform: scale(0.8); } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }
        #final-boards-container { display: flex; flex-direction: column; gap: 2rem; margin-top: 1rem; }
        #ship-config-container { display: flex; flex-direction: column; gap: 1rem; text-align: left; }
        .ship-config-option { display: grid; grid-template-columns: 1fr auto auto; align-items: center; gap: 1rem; background: var(--bg-color); padding: 0.5rem 0.8rem; border-radius: 8px; }
        .ship-config-option input { width: 60px; padding: 0.5rem; background: var(--secondary-color); color: var(--accent-color); border: none; border-radius: 5px; text-align: center; }
        .ship-preview-icon { display: grid; gap: 2px; }
        .ship-preview-icon .mini-block { width: 8px; height: 8px; background-color: var(--accent-color); border-radius: 1px; }
        @media (max-width: 767px) { .screen-content { padding: 1rem; } #ship-selection-panel { max-height: 25vh; overflow-y: auto; margin-bottom: 1rem; } }
        @media (min-width: 768px) { .placement-layout { flex-direction: row; align-items: flex-start; } #final-boards-container { flex-direction: row; align-items: flex-start; } :root { --cell-size: 45px; } #game-over-screen .grid-container { --cell-size: 30px; } }
        .ship-part-rendered { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transition: all 0.3s ease; }
        .grid-container.filled-style .cell.ship-part { filter: drop-shadow(0 2px 3px rgba(0,0,0,0.4)); z-index: 1; position: relative; }
        .filled-style .ship-part-rendered { background: linear-gradient(160deg, #ffffff, #c1c8d0); }
        .filled-style .is-top-left { border-top-left-radius: 40%; } .filled-style .is-top-right { border-top-right-radius: 40%; } .filled-style .is-bottom-left { border-bottom-left-radius: 40%; } .filled-style .is-bottom-right { border-bottom-right-radius: 40%; }
        .outline-style .ship-part-rendered { background: transparent; } .outline-style .is-top-edge { border-top: 2px solid white; } .outline-style .is-bottom-edge { border-bottom: 2px solid white; } .outline-style .is-left-edge { border-left: 2px solid white; } .outline-style .is-right-edge { border-right: 2px solid white; }
        .outline-style .is-top-left { border-top-left-radius: 12px; } .outline-style .is-top-right { border-top-right-radius: 12px; } .outline-style .is-bottom-left { border-bottom-left-radius: 12px; } .outline-style .is-bottom-right { border-bottom-right-radius: 12px; }
        .classic-style .ship-part-rendered { background: linear-gradient(160deg, #d4d7dd, #97aabd); }
        .classic-style .is-bow.is-horizontal { clip-path: polygon(0 0, 100% 50%, 0 100%); } .classic-style .is-stern.is-horizontal { clip-path: polygon(100% 0, 0 50%, 100% 100%); } .classic-style .is-bow.is-vertical { clip-path: polygon(0 0, 100% 0, 50% 100%); } .classic-style .is-stern.is-vertical { clip-path: polygon(50% 0, 100% 100%, 0 100%); }
        .classic-style .is-top-left:not(.is-bow):not(.is-stern) { border-top-left-radius: 50%; } .classic-style .is-top-right:not(.is-bow):not(.is-stern) { border-top-right-radius: 50%; } .classic-style .is-bottom-left:not(.is-bow):not(.is-stern) { border-bottom-left-radius: 50%; } .classic-style .is-bottom-right:not(.is-bow):not(.is-stern) { border-bottom-right-radius: 50%; }
        .threed-style .ship-part-rendered { background: #b0b8c1; transform: translate(-3px, -3px); box-shadow: 3px 3px 0px 0px #6a7179; }
        .threed-style .is-top-left { border-top-left-radius: 6px; } .threed-style .is-top-right { border-top-right-radius: 6px; } .threed-style .is-bottom-left { border-bottom-left-radius: 6px; } .threed-style .is-bottom-right { border-bottom-right-radius: 6px; }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="setup-screen" class="screen active">
            <div class="screen-content">
                <h1 class="title">Hundir la Flota</h1>
                <div id="ship-config-container" style="margin: 2rem 0;">
                    <div class="ship-config-option">
                        <label for="grid-size-input">Tamaño Cuadrícula</label>
                        <span></span>
                        <input type="number" id="grid-size-input" value="10" min="8" max="15">
                    </div>
                </div>
                <button id="start-placement-btn" class="btn btn-primary">Iniciar Colocación</button>
            </div>
        </div>
        <div id="placement-screen" class="screen">
            <div class="screen-content">
                <h2 id="player-turn-msg"></h2>
                <div class="placement-layout">
                    <div id="ship-selection-panel">
                        <h3>Tu Flota</h3>
                        <p style="font-size: 0.8rem; opacity: 0.7;">
                            Toca un barco para seleccionarlo. <br>
                            Doble toque en el tablero para girarlo.
                        </p>
                        <div id="ship-list"></div>
                        <div id="placement-controls">
                            <button id="change-style-btn" class="btn">Cambiar Estilo</button>
                            <button id="undo-btn" class="btn btn-danger">Deshacer</button>
                        </div>
                    </div>
                    <div id="placement-grid" class="grid-container filled-style"></div>
                </div>
                <button id="confirm-placement-btn" class="btn btn-primary" style="margin-top: 1rem;">Confirmar Flota</button>
            </div>
        </div>
        <div id="turn-switch-screen" class="screen modal"> <div class="screen-content"> <h2 id="next-player-msg"></h2> <p id="turn-switch-subtitle"></p> <button id="next-turn-btn" class="btn">¡Listo!</button> </div> </div>
        <div id="game-screen" class="screen"> <div class="screen-content"> <h2 id="current-player-msg"></h2> <div id="game-header"><div id="ships-status-panel"></div></div> <div id="attack-grid" class="grid-container filled-style"></div> </div> </div>
        <div id="game-over-screen" class="screen"> <div class="screen-content"> <h2 id="winner-msg"></h2> <div id="final-boards-container"> <div> <h3>Flota del Jugador 1</h3> <div id="final-grid-1" class="grid-container filled-style"></div> </div> <div> <h3>Flota del Jugador 2</h3> <div id="final-grid-2" class="grid-container filled-style"></div> </div> </div> <button id="play-again-btn" class="btn btn-primary">Jugar de Nuevo</button> </div> </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const screens = { setup: document.getElementById('setup-screen'), placement: document.getElementById('placement-screen'), turnSwitch: document.getElementById('turn-switch-screen'), game: document.getElementById('game-screen'), gameOver: document.getElementById('game-over-screen'), };
            const grids = { placement: document.getElementById('placement-grid'), attack: document.getElementById('attack-grid'), final1: document.getElementById('final-grid-1'), final2: document.getElementById('final-grid-2'), };
            const messages = { playerTurn: document.getElementById('player-turn-msg'), currentPlayer: document.getElementById('current-player-msg'), nextPlayer: document.getElementById('next-player-msg'), turnSwitchSubtitle: document.getElementById('turn-switch-subtitle'), winner: document.getElementById('winner-msg'), };
            const buttons = { startPlacement: document.getElementById('start-placement-btn'), confirmPlacement: document.getElementById('confirm-placement-btn'), nextTurn: document.getElementById('next-turn-btn'), changeStyle: document.getElementById('change-style-btn'), undo: document.getElementById('undo-btn'), playAgain: document.getElementById('play-again-btn'), };
            const panels = { shipList: document.getElementById('ship-list'), shipConfigContainer: document.getElementById('ship-config-container'), shipsStatus: document.getElementById('ships-status-panel') };

            let GRID_SIZE = 10, player1Ships = [], player2Ships = [], player1Shots = [], player2Shots = [];
            let placingPlayer = 1, shipsToPlace = [], currentPlacingShip = null, currentPreviewPositions = [];
            let rotationIndex = 0, currentPlayer = 1;
            const shipStyles = ['filled-style', 'outline-style', 'classic-style', 'threed-style']; let currentStyleIndex = 0;

            const defineShipShapes = () => [
                { name: 'Portaaviones', count: 1, shapes: [[{x:0,y:0},{x:1,y:0},{x:2,y:0},{x:1,y:1},{x:2,y:1},{x:3,y:1}],[{x:1,y:0},{x:1,y:1},{x:1,y:2},{x:0,y:1},{x:0,y:2},{x:0,y:3}],[{x:0,y:1},{x:1,y:1},{x:2,y:1},{x:1,y:0},{x:2,y:0},{x:3,y:0}],[{x:0,y:0},{x:0,y:1},{x:0,y:2},{x:1,y:1},{x:1,y:2},{x:1,y:3}]] },
                { name: 'Acorazado', count: 1, shapes: [[{x:0,y:0},{x:1,y:0},{x:2,y:0},{x:1,y:1}],[{x:0,y:1},{x:1,y:0},{x:1,y:1},{x:1,y:2}],[{x:0,y:1},{x:1,y:1},{x:2,y:1},{x:1,y:0}],[{x:0,y:0},{x:0,y:1},{x:0,y:2},{x:1,y:1}]] },
                { name: 'Submarino', count: 1, shapes: [[{x:0,y:0},{x:1,y:0},{x:2,y:0},{x:3,y:0},{x:4,y:0}],[{x:0,y:0},{x:0,y:1},{x:0,y:2},{x:0,y:3},{x:0,y:4}],[{x:0,y:0},{x:1,y:0},{x:2,y:0},{x:3,y:0},{x:4,y:0}],[{x:0,y:0},{x:0,y:1},{x:0,y:2},{x:0,y:3},{x:0,y:4}]], isLinear: true },
                { name: 'Destructor', count: 2, shapes: [[{x:0,y:0},{x:1,y:0},{x:2,y:0}],[{x:0,y:0},{x:0,y:1},{x:0,y:2}],[{x:0,y:0},{x:1,y:0},{x:2,y:0}],[{x:0,y:0},{x:0,y:1},{x:0,y:2}]], isLinear: true },
                { name: 'Corbeta', count: 2, shapes: [[{x:0,y:0},{x:1,y:0}],[{x:0,y:0},{x:0,y:1}],[{x:0,y:0},{x:1,y:0}],[{x:0,y:0},{x:0,y:1}]], isLinear: true },
            ];

            function init() {
                Object.values(buttons).forEach(btn => btn.addEventListener('click', handleButtonClick));
                populateShipConfig();
                addPlacementListeners();
            }

            function handleButtonClick(e) {
                switch (e.target.id) {
                    case 'start-placement-btn': handleStartPlacement(); break;
                    case 'confirm-placement-btn': handleConfirmPlacement(); break;
                    case 'next-turn-btn': handleNextTurn(); break;
                    case 'change-style-btn': handleChangeStyle(); break;
                    case 'undo-btn': handleUndo(); break;
                    case 'play-again-btn': location.reload(); break;
                }
            }
            
            function populateShipConfig() {
                panels.shipConfigContainer.querySelectorAll('.ship-config-option:not(:first-child)').forEach(el => el.remove());
                defineShipShapes().forEach(({ name, count, shapes }) => {
                    const option = document.createElement('div');
                    option.className = 'ship-config-option';
                    const preview = document.createElement('div');
                    preview.className = 'ship-preview-icon';
                    const shape = shapes[0];
                    const width = Math.max(...shape.map(p => p.x)) + 1;
                    const height = Math.max(...shape.map(p => p.y)) + 1;
                    preview.style.gridTemplateColumns = `repeat(${width}, 8px)`;
                    preview.style.gridTemplateRows = `repeat(${height}, 8px)`;
                    shape.forEach(p => {
                        const block = document.createElement('div');
                        block.className = 'mini-block';
                        block.style.gridColumn = p.x + 1;
                        block.style.gridRow = p.y + 1;
                        preview.appendChild(block);
                    });
                    option.innerHTML = `<span>${name}</span>`;
                    option.appendChild(preview);
                    option.innerHTML += `<input type="number" value="${count}" min="0" max="5" data-name="${name}">`;
                    panels.shipConfigContainer.appendChild(option);
                });
            }

            const switchScreen = (activeScreen) => { Object.values(screens).forEach(s => s.classList.remove('active')); screens[activeScreen].classList.add('active'); };

            function handleStartPlacement() {
                GRID_SIZE = parseInt(document.getElementById('grid-size-input').value) || 10;
                document.documentElement.style.setProperty('--grid-size', GRID_SIZE);
                shipsToPlace = [];
                const shipDefs = defineShipShapes();
                panels.shipConfigContainer.querySelectorAll('input[data-name]').forEach(input => {
                    const count = parseInt(input.value);
                    const shipDef = shipDefs.find(s => s.name === input.dataset.name);
                    for (let i = 0; i < count; i++) shipsToPlace.push({ ...shipDef, uniqueName: `${shipDef.name} ${i + 1}`, placed: false });
                });
                player1Ships = []; player2Ships = []; player1Shots = []; player2Shots = [];
                placingPlayer = 1;
                startPlacementPhase();
            }

            function startPlacementPhase() {
                createGrid(grids.placement);
                messages.playerTurn.textContent = `Jugador ${placingPlayer}, coloca tu flota`;
                updateShipList();
                switchScreen('placement');
            }

            function handleConfirmPlacement() {
                if (shipsToPlace.every(s => s.placed)) {
                    if (placingPlayer === 1) {
                        placingPlayer = 2;
                        shipsToPlace.forEach(s => s.placed = false);
                        messages.nextPlayer.textContent = `Turno de colocar para Jugador 2`;
                        messages.turnSwitchSubtitle.textContent = 'Pasa el dispositivo a tu oponente.';
                        switchScreen('turnSwitch');
                    } else {
                        startGame();
                    }
                } else {
                    alert('Debes colocar todos los barcos antes de continuar.');
                }
            }

            function handleNextTurn() {
                if (placingPlayer === 2 && !player2Ships.length) {
                    startPlacementPhase();
                } else {
                    setupTurn();
                }
            }

            const createGrid = (gridEl) => {
                gridEl.innerHTML = '';
                for (let y = 0; y < GRID_SIZE; y++) for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell'; cell.dataset.x = x; cell.dataset.y = y;
                    gridEl.appendChild(cell);
                }
            };
            
            function addPlacementListeners() {
                let lastInteractionTime = 0;
                const doubleClickDelay = 300;
                let lastCell = null;

                const handlePointerMove = (e) => {
                    const isTouch = e.type.includes('touch');
                    if (isTouch) e.preventDefault();
                    const point = isTouch ? e.touches[0] : e;
                    const elementOver = document.elementFromPoint(point.clientX, point.clientY);
                    const cell = elementOver ? elementOver.closest('.cell') : null;

                    if (currentPlacingShip && cell) {
                        previewShip(cell);
                        lastCell = cell;
                    }
                };
                
                const handlePointerUp = (e) => {
                    const currentTime = new Date().getTime();
                    const timeSinceLast = currentTime - lastInteractionTime;
                    const cell = e.target.closest('.cell');
                    
                    if (timeSinceLast < doubleClickDelay) { // Doble clic/toque
                        handleGridRotation(cell || lastCell);
                    } else { // Clic/toque simple
                        handlePlacementGridInteraction(cell || lastCell);
                    }
                    lastInteractionTime = currentTime;
                    if(e.type === 'touchend') clearPreview();
                };

                grids.placement.addEventListener('mousemove', handlePointerMove);
                grids.placement.addEventListener('touchmove', handlePointerMove, { passive: false });
                grids.placement.addEventListener('mouseleave', clearPreview);
                grids.placement.addEventListener('mouseup', handlePointerUp);
                grids.placement.addEventListener('touchend', handlePointerUp);
            }

            function handlePlacementGridInteraction(cell) {
                if (!cell) return;
                if (currentPlacingShip) { placeShip(cell); } else { pickUpShip(cell); }
            }

            function handleGridRotation(cell) {
                if (currentPlacingShip && cell) {
                    const isInteractionOnPreview = currentPreviewPositions.some(p => p.x == cell.dataset.x && p.y == cell.dataset.y);
                    if (isInteractionOnPreview) { handleRotateShip(); previewShip(cell); }
                }
            }
            
            function placeShip(cell) {
                if (!currentPlacingShip) return;
                const { positions, isValid } = getShipPositions(cell);
                if (isValid) {
                    const shipData = { ...currentPlacingShip, positions, rotation: rotationIndex, hits: 0 };
                    (placingPlayer === 1 ? player1Ships : player2Ships).push(shipData);
                    renderShipOutline(grids.placement, shipData);
                    currentPlacingShip.placed = true;
                    currentPlacingShip = null;
                    updateShipList();
                }
            }

            function pickUpShip(cell) {
                if(!cell) return;
                const x = parseInt(cell.dataset.x), y = parseInt(cell.dataset.y);
                const playerShips = placingPlayer === 1 ? player1Ships : player2Ships;
                const shipToMove = playerShips.find(s => s.positions.some(p => p.x === x && p.y === y));
                if (shipToMove) {
                    playerShips.splice(playerShips.findIndex(s => s.uniqueName === shipToMove.uniqueName), 1);
                    shipToMove.positions.forEach(({ x, y }) => { const cellEl = grids.placement.querySelector(`[data-x='${x}'][data-y='${y}']`); if(cellEl) { cellEl.innerHTML = ''; cellEl.className = 'cell'; } });
                    const shipDef = shipsToPlace.find(s => s.uniqueName === shipToMove.uniqueName);
                    shipDef.placed = false;
                    currentPlacingShip = shipDef;
                    rotationIndex = shipToMove.rotation;
                    updateShipList();
                    previewShip(cell);
                }
            }

            function handleUndo() {
                const playerShips = placingPlayer === 1 ? player1Ships : player2Ships;
                if (!playerShips.length) return;
                const lastShip = playerShips[playerShips.length - 1];
                pickUpShip(grids.placement.querySelector(`[data-x='${lastShip.positions[0].x}'][data-y='${lastShip.positions[0].y}']`));
            }

            function updateShipList() {
                panels.shipList.innerHTML = '';
                shipsToPlace.sort((a,b) => a.placed - b.placed || a.name.localeCompare(b.name)).forEach(ship => {
                    const shipEl = document.createElement('div');
                    shipEl.className = 'ship-item'; shipEl.textContent = ship.name; shipEl.dataset.name = ship.uniqueName;
                    if (ship.placed) shipEl.classList.add('placed');
                    if (currentPlacingShip?.uniqueName === ship.uniqueName) shipEl.classList.add('placing');
                    shipEl.addEventListener('click', () => {
                        if (ship.placed) { pickUpShip(grids.placement.querySelector(`[data-x='${ship.positions[0].x}'][data-y='${ship.positions[0].y}']`)); return; }
                        if (shipEl.classList.contains('placing')) { handleRotateShip(); } else { currentPlacingShip = shipsToPlace.find(s => s.uniqueName === ship.uniqueName); rotationIndex = 0; updateShipList(); }
                    });
                    panels.shipList.appendChild(shipEl);
                });
                if (!currentPlacingShip || currentPlacingShip.placed) {
                    currentPlacingShip = shipsToPlace.find(s => !s.placed) || null;
                    if(currentPlacingShip) panels.shipList.querySelector(`[data-name="${currentPlacingShip.uniqueName}"]`)?.classList.add('placing');
                }
            }

            const handleRotateShip = () => { if(currentPlacingShip) rotationIndex = (rotationIndex + 1) % 4; };
            
            function handleChangeStyle() {
                currentStyleIndex = (currentStyleIndex + 1) % shipStyles.length;
                const newStyle = shipStyles[currentStyleIndex];
                Object.values(grids).forEach(grid => { grid.className = 'grid-container'; grid.classList.add(newStyle); });
            };

            const getShipPositions = (startCell) => {
                if(!currentPlacingShip || !startCell) return {positions: [], isValid: false};
                const x = parseInt(startCell.dataset.x), y = parseInt(startCell.dataset.y);
                const currentShape = currentPlacingShip.shapes[rotationIndex];
                const positions = currentShape.map(p => ({ x: x + p.x, y: y + p.y }));
                const playerShips = placingPlayer === 1 ? player1Ships : player2Ships;
                const isValid = positions.every(p => p.x >= 0 && p.x < GRID_SIZE && p.y >= 0 && p.y < GRID_SIZE) && !positions.some(p1 => playerShips.some(ship => ship.positions.some(p2 => p1.x === p2.x && p1.y === p2.y)));
                return { positions, isValid };
            };

            const previewShip = (cell) => { clearPreview(); if (!currentPlacingShip || !cell) return; const { positions, isValid } = getShipPositions(cell); currentPreviewPositions = positions; positions.forEach(({ x, y }) => { const cellEl = grids.placement.querySelector(`[data-x='${x}'][data-y='${y}']`); if (cellEl) cellEl.classList.add(isValid ? 'preview' : 'invalid'); }); };
            const clearPreview = () => { grids.placement.querySelectorAll('.cell.preview, .cell.invalid').forEach(c => c.classList.remove('preview', 'invalid')); currentPreviewPositions = []; };

            function renderShipOutline(grid, ship) {
                const isPart = (x, y) => ship.positions.some(p => p.x === x && p.y === y);
                let minX = GRID_SIZE, minY = GRID_SIZE, maxX = -1, maxY = -1;
                if(ship.isLinear) ship.positions.forEach(p => { minX = Math.min(minX, p.x); minY = Math.min(minY, p.y); maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); });
                ship.positions.forEach(p => {
                    const cellEl = grid.querySelector(`[data-x='${p.x}'][data-y='${p.y}']`); if (!cellEl) return;
                    cellEl.className = 'cell ship-part';
                    const partDiv = document.createElement('div');
                    partDiv.className = 'ship-part-rendered';
                    const hasN = { top: isPart(p.x, p.y - 1), bottom: isPart(p.x, p.y + 1), left: isPart(p.x - 1, p.y), right: isPart(p.x + 1, p.y) };
                    if (!hasN.top) partDiv.classList.add('is-top-edge'); if (!hasN.bottom) partDiv.classList.add('is-bottom-edge');
                    if (!hasN.left) partDiv.classList.add('is-left-edge'); if (!hasN.right) partDiv.classList.add('is-right-edge');
                    if (!hasN.top && !hasN.left) partDiv.classList.add('is-top-left'); if (!hasN.top && !hasN.right) partDiv.classList.add('is-top-right');
                    if (!hasN.bottom && !hasN.left) partDiv.classList.add('is-bottom-left'); if (!hasN.bottom && !hasN.right) partDiv.classList.add('is-bottom-right');
                    if (ship.isLinear) { const isHorizontal = minY === maxY; partDiv.classList.add(isHorizontal ? 'is-horizontal' : 'is-vertical'); if (isHorizontal && p.x === minX || !isHorizontal && p.y === minY) partDiv.classList.add('is-bow'); if (isHorizontal && p.x === maxX || !isHorizontal && p.y === maxY) partDiv.classList.add('is-stern'); }
                    cellEl.appendChild(partDiv);
                });
            }

            function startGame() {
                createGrid(grids.attack);
                grids.attack.querySelectorAll('.cell').forEach(c => c.addEventListener('click', e => handleAttack(e.target)));
                currentPlayer = 1;
                setupTurn();
            }

            function setupTurn() {
                messages.currentPlayer.textContent = `Turno del Jugador ${currentPlayer}`;
                updateShipsStatus();
                renderAttackGrid();
                switchScreen('game');
            }
            
            function handleAttack(cell) {
                if (!cell || cell.classList.contains('hit') || cell.classList.contains('miss')) return;
                const x = parseInt(cell.dataset.x), y = parseInt(cell.dataset.y);
                const shots = currentPlayer === 1 ? player1Shots : player2Shots;
                shots.push({ x, y });
                const opponentShips = currentPlayer === 1 ? player2Ships : player1Ships;
                const targetShip = opponentShips.find(ship => ship.positions.some(p => p.x === x && p.y === y));

                if (targetShip) {
                    cell.classList.add('hit');
                    const shipPart = targetShip.positions.find(p => p.x === x && p.y === y);
                    if (!shipPart.hit) { shipPart.hit = true; targetShip.hits = (targetShip.hits || 0) + 1; }
                    
                    const totalHits = targetShip.positions.filter(p => p.hit).length;
                    if (totalHits >= targetShip.positions.length) {
                        targetShip.positions.forEach(p => { grids.attack.querySelector(`[data-x='${p.x}'][data-y='${p.y}']`).classList.add('sunk'); });
                        if(opponentShips.every(s => s.positions.filter(p=>p.hit).length >= s.positions.length)) { setTimeout(endGame, 500); return; }
                    }
                    updateShipsStatus();
                } else {
                    cell.classList.add('miss');
                    messages.nextPlayer.textContent = `¡Agua! Cediendo el turno...`;
                    messages.turnSwitchSubtitle.textContent = `Ahora juega el Jugador ${currentPlayer === 1 ? 2 : 1}`;
                    switchScreen('turnSwitch');
                    setTimeout(() => { currentPlayer = (currentPlayer % 2) + 1; setupTurn(); }, 2000);
                }
            }
            
            function updateShipsStatus() {
                panels.shipsStatus.innerHTML = '';
                const opponentShips = currentPlayer === 1 ? player2Ships : player1Ships;
                opponentShips.forEach(ship => {
                    const el = document.createElement('div');
                    el.className = 'ship-status';
                    const hits = ship.positions.filter(p => p.hit).length;
                    if (hits >= ship.positions.length) { el.classList.add('sunk'); } 
                    else if (hits > 0) { el.classList.add('damaged'); }
                    el.textContent = ship.name;
                    panels.shipsStatus.appendChild(el);
                });
            }

            function renderAttackGrid() {
                const shots = currentPlayer === 1 ? player1Shots : player2Shots;
                const opponentShips = currentPlayer === 1 ? player2Ships : player1Ships;
                grids.attack.querySelectorAll('.cell').forEach(cell => {
                    cell.className = 'cell';
                    const x = parseInt(cell.dataset.x), y = parseInt(cell.dataset.y);
                    const shot = shots.find(s => s.x === x && s.y === y);
                    if(shot) {
                        const hitShip = opponentShips.find(ship => ship.positions.some(p => p.x === x && p.y === y));
                        if (hitShip) {
                            cell.classList.add('hit');
                            if (hitShip.positions.filter(p=>p.hit).length >= hitShip.positions.length) cell.classList.add('sunk');
                        } else cell.classList.add('miss');
                    }
                });
            }

            function endGame() {
                messages.winner.textContent = `¡Jugador ${currentPlayer} ha ganado!`;
                createGrid(grids.final1); createGrid(grids.final2);
                renderFinalBoard(grids.final1, player1Ships, player2Shots);
                renderFinalBoard(grids.final2, player2Ships, player1Shots);
                switchScreen('gameOver');
            }

            function renderFinalBoard(grid, ships, oppShots) {
                ships.forEach(ship => renderShipOutline(grid, ship));
                oppShots.forEach(shot => {
                    const cell = grid.querySelector(`[data-x='${shot.x}'][data-y='${shot.y}']`);
                    if(cell) cell.classList.add(ships.some(s => s.positions.some(p => p.x === shot.x && p.y === shot.y)) ? 'hit' : 'miss');
                });
            }
            
            init();
        });
    </script>
</body>
</html>
